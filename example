# defp fetch_orders_page_with_etag({region_id, page} = key, current_etag) do
#   headers = maybe_put_if_none_match([], current_etag)

#   case ESI.Market.get_region_orders(region_id, %{order_type: "all", page: page}, headers) do
#     {:ok, %ESI.Response{status: 304, headers: resp_headers}} ->
#       new_etag = find_etag(resp_headers) || current_etag
#       {:not_modified, key, new_etag}

#     {:ok, %ESI.Response{status: 200, headers: resp_headers, body: body}} when is_list(body) ->
#       new_etag = find_etag(resp_headers) || current_etag
#       upsert_orders(body, etag_key(key), new_etag)
#       {:ok, key, new_etag}

#     other ->
#       {:error, key, other}
#   end
# end


# map = map
#       |> Map.put(:etag_scope, "#{region_id}-#{page}")
#       |> Map.put(:etag_value, etag)




# # migration
# create table(:markets) do
#   add :order_id, :bigint, primary_key: true
#   add :type_id, :bigint
#   add :price, :decimal
#   add :volume_remain, :bigint
#   add :volume_total, :bigint
#   add :duration, :integer
#   add :is_buy_order, :boolean
#   add :issued, :naive_datetime
#   add :location_id, :bigint
#   add :min_volume, :bigint
#   add :range, :string
#   add :system_id, :bigint
#   add :etag_url, :text  # Links order to its source page
#   add :etag_value, :text  # Links order to its ETag
# end

# create table(:etags) do
#   add :url, :text, primary_key: true
#   add :etag, :text
# end

# create table(:markets) do
#   add :order_id, :bigint, primary_key: true
#   add :etag_url, :text, null: false, index: true  # Critical index
#   add :etag_value, :text, null: false
#   add :type_id, :bigint, index: true
#   add :price, :decimal, index: true
#   add :is_buy_order, :boolean, index: true
#   add :updated_at, :utc_datetime, null: false
# end

# create unique index(:markets, [:etag_url, :order_id])  # Prevent dupes
